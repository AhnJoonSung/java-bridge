## 프로그램 소개
턴마다 위, 아래 둘 중 하나의 칸을 선택해 다리를 끝까지 건너가는 게임이다.

## 프로그램 제약 사항
- 함수의 길이가 10라인을 넘어가지 않도록 구현한다. 
- 함수의 파라미터 개수는 최대 3개까지만 허용한다.
- BridgeGame 클래스에서 InputView, OutputView를 사용하지 않는다.
- InputView 클래스
  - InputView 클래스에서만 Console.readLine() 메소드를 이용해 사용자의 입력을 받을 수 있다.
  - InputView의 메소드의 시그니처(인자, 이름)와 반환 타입은 변경할 수 없다.
  - 사용자 값 입력을 위해 필요한 메소드를 추가할 수 있다.
- OutputView 클래스
  - 메소드의 이름은 변경할 수 없고, 인자와 반환 타입은 필요에 따라 추가하거나 변경할 수 있다.
  - 값 출력을 위해 필요한 메소드를 추가할 수 있다. 
- BridgeGame 클래스
  - 인스턴스 변수(필드)를 추가할 수 있다.
  - 메소드의 이름은 변경할 수 없고, 인자와 반환 타입은 추가하거나 변경할 수 있다. 
  - 게임 진행을 위해 필요한 메서드를 추가하거나 변경할 수 있다. 
- BridgeMaker 클래스
  - 필드를 변경할 수 없다.
  - 메서드의 시그니처와 반환 타입은 변경할 수 없다.
- BridgeRandomNumberGenerator 클래스
  - Random 값 추출은 해당 클래스의 generate()를 활용한다. 
  - BridgeRandomNumberGenerator, BridgeNumberGenerator 클래스의 코드는 변경할 수 없다. 

## 공통 피드백 사항
- 비즈니스 로직과 UI 로직을 한 클래스가 담당하지 않도록 한다. 
  - 단일 책임의 원칙에도 위배된다.
  - 현재 객체의 상태를 보기 위한 로그 메시지 성격이 강하다면 Object의 toString()을 오버라이드해 구현한다. 
  - View에서 사용할 데이터라면 getter 메서드를 통해 데이터를 전달한다. 
- 연관성이 있는 상수는 static final 대신 enum을 활용한다. 
- final 키워드를 사용해 값의 변경을 막는다.
  - 최근에 등장하는 프로그래밍 언어들은 기본이 불변 값이다. 자바는 final 키워드를 통해 값의 변경을 막을 수 있다. 
- 객체의 상태 접근을 제한한다. 
  - 인스턴스 변수의 접근 제어자는 private로 구현한다. 
- 객체는 객체스럽게 사용한다. 
  - 상태 데이터를 꺼내 로직을 처리하도록 구현하지 말고 객체에 메세지를 보내 일을 하도록 한다.  
  - Lotto에서 데이터를 꺼내서 사용하는 식이 아닌 Lotto에서 메세지를 던지도록 구조를 바꿔 데이터를 가지는 객체가 일하도록 한다. 
    - ex) lotto.getNumbers.contains(number) - X
    - Lotto에 contains()를 만들어 사용 - O
- getter를 무조건 사용하지 말라는 말은 아니다. 
  - 출력을 위한 값 등 순수 값 프로퍼티을 가져오기 위해서라면 어느정도의 getter는 허용된다. 
  - 그러나, Collection 인터페이를 사용하는 경우 외부에서 getter 메소드로 얻은 값을 통해 상태 값을 변경할 수 있다. 
  - Collections.unmodifiableList()와 같은 Unmodifiable Collection을 사용해 외부에서 변경하지 못하도록 하는게 좋다. 
    - ex) return Collections.unmodifiableList(cars);
- 필드의 수를 줄이기 위해 노력한다. 
  - 필드의 수가 많은 것은 객체의 복잡도와 버그 발생률을 높일 수 있다. 
  - 필드에 중복이 있거나, 불필요한 필드가 있는지 확인 해 필드의 수를 최소화한다. 
- 예외에 대한 케이스도 테스트한다. 
  - 특히 경계값 부분은 결함이 많이 발생하므로 꼼꼼하게 확인한다. 
- 테스트 코드도 코드다. 
  - 테스트 코드도 코드이므로 리팩터링을 통해 개선해나가야 한다. 
  - 특히 반복적으로 하는 부분을 중복되지 않게 만들어야 한다. 예를 들어 단순히 파라미터의 값만 바뀌는 경우라면 @ValueSource(), @ParameterizedTest를 통해 테스트할 수 있따. 
- 테스트를 위한 코드는 구현 코드에서 분리되어야 한다. 
  - 테스트를 위한 편의 메서드를 구현 코드에 구현하지 마라. 아래의 예시처럼 테스트를 통과하기 위해 구현 코드를 변경하거나 테스트에서만 사용되는 로직을 만들지 않는다. 
    - 테스트를 위해 접근제어자를 변경하는 경우
    - 테스트 코드에서만 사용되는 메서드
- 단위 테스트하기 어려운 코드를 단위 테스트하기. 
  - 테스트하기 어려운 것을 클래스 외부로 분리해본다. 
  - 테스트하기 어려운 부분을 분리해 테스트 가능한 부분은 테스트하고 테스트하기 어려운 부분은 단위 테스트하지 않아도 된다. 의존성이 옮겨간 부분은 어떻게 테스트할 수 있을지 고민해 본다. 
- private 함수를 테스하고 싶다면 클래스 분리를 고려한다. 
  - 가독성의 이유만으로 분리한 private 함수의 경우, public 함수에 의해 사용되어 지므로 자연스럽게 테스트 범위에 포함된다. 하지만 가독성 이상의 역할을 하는 경우, 테스트하기 쉽게 구현하기 위해 해당 역할을 수행하는 다른 객체를 만들 타이밍이 아닌지 고민해 본다. 너무 많은 역할을 하고 있는 함수나 객체를 어떻게 의미있는 단위로 분할할지 고민해본다. 


## 기능 목록
- 다리의 길이를 입력 받는다. 
  - 입력 안내 메세지를 출력한다. 
  - 값을 입력 받는다. 
  - 값의 유효성을 검증한다. 
- 다리를 생성한다. 
  - 매 칸마다 0과 1중 무작위 값을 뽑는다. 
  - 그에 대응하는 U,D로 다리를 생성한다. 
  - 길이 만큼 반복한다. 
- 이동할 칸을 입력 받는다. 
  - 입력 안내 메세지를 출력한다. 
  - 값을 입력 받는다. 
  - 값의 유효성을 검증한다. 
  - 값에 대한 결과를 계산한다. 
  - 현재까지 건넌 다리를 출력한다. 
- 한 칸 이동한 결과에 따라 다른 흐름을 진행한다.
  - 이동에 성공했다면 다리를 다 건넜는지 체크한다. 
    - 다리를 다 건넜다면 게임 종료 문구를 출력하고 종료한다. 
    - 다리를 다 건너지 않았다면 이동할 칸을 입력 받는다.
  - 이동에 실패했다면 사용자의 입력을 받는다. 
    - "R"을 입력 받으면 게임을 재시작 한다. 
    - "Q"를 입력 받으면 게임 종료 문구를 출력하고 종료한다. 
    - 이 외의 값이 들어오면 예외 처리한다.
- 현재까지 건넌 다리
  - 위 칸과 아래 칸 중 건너는데 성공한 곳에 "O", 실패한 곳에 "X"를 표시하고 건너지 않은 곳은 공백으로 표시한다. 
- 게임 종료 문구
  - 현재까지 건넌 다리를 모두 출력한다. 
  - 게임성공 여부를 "성공" or "실패" 로 나타낸다. 
  - 총 시도한 횟수를 표시한다. 
